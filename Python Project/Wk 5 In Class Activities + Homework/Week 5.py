# -*- coding: utf-8 -*-
"""Week_5_answer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m-uPbwwdss0p2uR4GHiPJ6OaXvbsQ5ai

**Week 5 (Functions and Modules)**  <br /> 
Natalie Agus, Digital World 2020

**Problem 1**  `Game Craps` <br/>
Why do we want to use functions here? 


*   So that it is **reusable** in `play_craps()` function below. Identify any reusable functions inside `play_craps()`.
*   Looks more concised and modular, hence easier to **debug**
"""

import random

craps=set([2,3,12])
naturals=set([7,11])

## Simulates the rolling of a die
## Return two random numbers between 1 to 6 each

# @args: None
# @return: tuple of 2 integers
def roll_two_dices():
    n1=random.randint(1,6)
    n2=random.randint(1,6)
    return n1,n2

# @args: None
# @return: None
def print_lose():
    print ("You lose")

# @args: None
# @return: None
def print_win():
    print ("You win")

# @args: None
# @return: None
def print_point(p):
    print ('Your points are ',p)

# @args: integer n
# @return: boolean if n in craps
def is_craps(n):
    return n in craps   

# @args: integer n
# @return: boolean if n in naturals
def is_naturals(n):
    return n in naturals 

# @args: None
# @return: int 1 if win, 0 if lose
# The logic of craps game
def play_craps():
    # Indicate if we are at init stage
    point=-1
    # Goal of the game is to keep rolling dice until the sum == points obtained
    while True:
        # Obtain initial points by rolling two dice
        n1,n2=roll_two_dices()
        sumn=n1+n2
        print ('You rolled %d + %d = %d'%(n1,n2,sumn))  
        # If we are at init stage, check if craps, or naturals 
        if point==-1:              
            if is_craps(sumn):  #if the sum is in the set of craps
                print_lose()     #then it is an immediate loss
                return 0
            elif is_naturals(sumn):   #if the sum is in the set of naturals
                print_win()     #then it is an immediate  win
                return 1
            point=sumn # set the new target point as our current sum
            print_point(point)
        else: # Otherwise continue rolling until our sum is equivalent to point
            if sumn==7:
                print_lose()
                return 0
            elif sumn==point:
                print_win()
                return 1   
play_craps()

"""**REVIEW**

1.   Is sumn accumulative or not?
2.   What is the highest value of sumn that you can obtain? 
3.   If you were to try to write `play_craps()` without the functions, what will it look like?

**Problem 2**  `Calendar Year` <br/>
Why do we want to use functions here? 


*   So that it is **reusable** in many, many function below
*   Looks more concised and modular, hence easier to **debug**. This is a considerably long and tedious task. You certainly will be met with bugs here.

`Part (a): checks if a given year is a leap year` <br\>
Do not forget to **call** your function if you want to see any output!
"""

# @args: int, year between 1800 to 2099
# @return: boolean if year is leap year
def leap_year(year):
    if year%4 != 0:
        return False
    elif year%100 != 0:
        return True
    elif year%400 != 0:
        return False
    else:
        return True

leap_year(2000) # CALL your function to test!

"""`Part (b): returns the day of the week of Jan 1 from given year in argument` <br/>
The day of the week starts from 0 (Sun) and ends at 6 (Sat)
"""

# Note: days ARE ZERO indexed. It ranges from 0 to 6 (Sun to Sat)

# @args: int, year between 1800 to 2099
# @return: int, signifies first day in the year
def day_of_week_jan1(year):
    return (1 + 5*((year-1)%4) + 4*((year-1)%100) + 6*((year-1)%400))%7

day_of_week_jan1(2000) # CALL your function to test!

"""`Part (c): returns the number of days in a given month` <br/>
Do we need to reuse any functions in part (a) and (b) for this? Think about if we are tasked to print the number of days in a month of Feb, do we need to know if it is a `leap_year` first?
"""

# Note: months are NOT ZERO indexed. month_num ranges from 1 to 12 (Jan to Dec)

# @args: int month_num -- index of the month
#        int year -- the year in question
# @return: int, number of days in that month, year
def num_days_in_month(month_num, year):
    if month_num in [1,3,5,7,8,10,12]:
        return 31
    elif month_num == 2:
        return 29 if leap_year(year) else 28
    else:
        return 30

print("Number of days in Feb 2000 is:", num_days_in_month(2, 2000)) # CALL your function to test!
print("Number of days in Feb 1999 is:", num_days_in_month(2, 1999)) # CALL your function to test!

"""`Part (d): Constructing calendar month as a list of strings` <br/>
Things to note: 

*   Carefully study the text formatting, including the number of spaces. Recall what you have learned in the previous weeks about print formatting
*   Use the * to debug, so that you can "see" how many spaces you have made in between the printed dates
* Plan the pseudocode on how to construct your function first
* After completing, can you case which functions in part (a), (b) or (c) above will be used together with this function?
"""

# Constrict a calendar month as a list of strings
#
# 1. Store month names in a dictionary for us to "look up" and print the month name given a number easily 
# 2. Create a list for your return value (This list will contain the list of strings as your output, 
# There's ONE line of string to indicate contents of dates per week, plus one line for the month name in the beginning)
# For example:  Given construct_cal_month(9,1,30)
# Output: ['September', '     1  2  3  4  5  6', '  7  8  9 10 11 12 13', ' 14 15 16 17 18 19 20', ' 21 22 23 24 25 26 27', ' 28 29 30']
# 3. Initialise an empty string, pad it with spaces depending on first_day_of_month
# 4. Keep a counter to take note whether you need to keep increasing the string length within the week or 
# append the string to the list
# 5. When all days have been entered, return the lsit


# @args: int month_num -- index of the month
#        int first_day_of_month -- the first day of the month
#        int num_days_in_month -- the number of days in the month
# @return: list of strings forming calendar month
def construct_cal_month(month_num, first_day_of_month, num_days_in_month):
    month_names={1:'January',2:'February',3:'March',4:'April',5:'May',\
                       6:'June',7:'July',8:'August',9:'September',\
                       10:'October',11:'November',12:'December'}

    ret_val=[month_names[month_num]]
    week='   '*first_day_of_month
    day=first_day_of_month
    date=1
    while date<=num_days_in_month:
        while day<=6:
            week+='%3s'%date
            date+=1
            day+=1
            if date>num_days_in_month:
                break
        day=0
        ret_val.append(week)
        week=''
    return ret_val

construct_cal_month(9,1,30) # CALL your function to test!

"""`Part (e): Construct an entire calendar year as a list of strings` <br/>
You need to think carefully which functions in the previous parts can be reused to print a calendar year? 

*   Obviously to print a year worth of days, you can print them by months, like the one in part (d) 
*   Think about what function need to be used to produce the arguments required by `construct_cal_months` in part (d)
"""

# @args: int year
# @return: list of strings forming calendar year
def construct_cal_year(year):
    # call day_of_week_jan1 first to produce the arguments for construct_cal_months later on 
    # call leay_year to check if the current year is leap year
    leapyear = leap_year(year)
    firstday = day_of_week_jan1(year)

    calyear = [year]
    for i in range(1,13):
        numdays = num_days_in_month(i,leapyear) # use num_days_in_months to tell construct_cal_month how many days are there in the month
        calyear.append(construct_cal_month(i, firstday, numdays ))
        firstday = (firstday + numdays)%7
    return calyear

construct_cal_year(2000) # CALL your function to test!

"""`Part (f): Print an entire calendar year in the specified format` <br/>



*   Generate the list of strings for the entire calendar year
*   Print them accordingly in the format shown in problem set
"""

# @args: int year
# @return: None
def display_calendar(year):
    calendar = ""
    calendar_year = construct_cal_year(year)
    calendar_year.pop(0)
    for i, month in enumerate(calendar_year):
        for i, week in enumerate(month):
            calendar += week +"\n"
            if i == 0:
                calendar += "  S  M  T  W  T  F  S\n"
        if i !=11:
            calendar += "\n"
    return calendar.strip()
    
display_calendar(2000)

"""**Review**


1. Functions are very useful to break down your code into smaller parts that are more understandable 
2. Avoid bugs by modularizing your code (creating many functions) 
3. Serves as a systematic way to tackle a bigger problem, like the calendar function. 
4. How tedious `display_calendar` will be if we haven't incrementally written 
the smaller functions in the previous parts?

**Problem 3**  `Recursion` <br/>
Why do we want to use functions here? 


*   Recursion is a special type of method of solving a problem where the final solution **depends on the solution of the smaller instances** of the same problem. 
* When we say that a function recurse, it basically *calls itself*
* **Key points: **
  * Define a BASE case to stop the function from keep recursing 
  * Define the RECURSIVE case where we can reuse the same piece of code with simpler argument each time the function calls itself
"""

def fact(n):
    # base case
    if n <=1:
        return 1
    # recursive case
    else:
        return n * fact(n-1)

fact(5)

"""**REVIEW**

1. Can you rewrite fact in iterative way, i.e: with a for-loop or a while-loop without recursion? 
2. What happens if we remove the base case?
3. Could you draw the recursion tree of fact(5)? How many other functions fact(x) are called before fact(5) returns?
"""